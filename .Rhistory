current_wealth
horizon = 40
current_wealth = 10000
for(t in 1:horizon) {
return_t = rnorm(1, mean = 0.06, sd = 0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}
current_wealth
horizon = 40
current_wealth = 10000
for(t in 1:horizon) {
return_t = rnorm(1, mean = 0.06, sd = 0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}
current_wealth
library(tidyverse)
library(mosaic)
aapl_returns = read.csv("data/raw data/aapl_returns.csv", header = TRUE)
ggplot(aapl_returns) +
geom_histogram(aes(x = return, y = ..density..), binwidth = 0.005)
favstats(~return, data = aapl_returns) %>% round(4)
# count the really bad days where aapl lost at least 8% of its value in a single day
aapl_returns %>%
count(return <= -0.08)
aapl_returns %>%
count(return >= 0.10)
# function pnorm can give us how likely is such a four-sigma loss
# (lost at least 8% of its value in a single day) under the normal model
pnorm(-0.08, mean = 0.0013, sd = 0.0202)
# specifying that we want an upper-tail rather than a lower-tail probability
pnorm(0.10, mean = 0.0013, sd = 0.0202, lower.tail = FALSE)
annual_returns_since1928 = read.csv("data/raw data/annual_returns_since1928.csv", header = TRUE)
annual_returns_since1928 = annual_returns_since1928 %>%
# SP500_net, that measures each year’s “whole-market” return, net of inflation
mutate(SP500_net = SP500 - Inflation)
# compute the mean and standard deviation
favstats(~SP500_net, data = annual_returns_since1928) %>%
round(4)
ggplot(annual_returns_since1928) +
geom_histogram(aes(x = SP500_net, y = ..density..), binwidth = 0.05)
horizon=40
portfolio_stocks = do(10000)*{  # beginning of outer loop
current_wealth = 10000 # reset at the beginning of each simulated trajectory
for(t in 1:horizon) {  # start of inner loop
return_t = rnorm(1, mean=0.06, sd=0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}  # end of inner loop
# save the final value of wealth
current_wealth
}  # end of outer loop
View(portfolio_stocks)
library(tidyverse)
library(mosaic)
aapl_returns = read.csv("data/raw data/aapl_returns.csv", header = TRUE)
ggplot(aapl_returns) +
geom_histogram(aes(x = return, y = ..density..), binwidth = 0.005)
favstats(~return, data = aapl_returns) %>% round(4)
# count the really bad days where aapl lost at least 8% of its value in a single day
aapl_returns %>%
count(return <= -0.08)
aapl_returns %>%
count(return >= 0.10)
# function pnorm can give us how likely is such a four-sigma loss
# (lost at least 8% of its value in a single day) under the normal model
pnorm(-0.08, mean = 0.0013, sd = 0.0202)
# specifying that we want an upper-tail rather than a lower-tail probability
pnorm(0.10, mean = 0.0013, sd = 0.0202, lower.tail = FALSE)
annual_returns_since1928 = read.csv("data/raw data/annual_returns_since1928.csv", header = TRUE)
annual_returns_since1928 = annual_returns_since1928 %>%
# SP500_net, that measures each year’s “whole-market” return, net of inflation
mutate(SP500_net = SP500 - Inflation)
# compute the mean and standard deviation
favstats(~SP500_net, data = annual_returns_since1928) %>%
round(4)
ggplot(annual_returns_since1928) +
geom_histogram(aes(x = SP500_net, y = ..density..), binwidth = 0.05)
# run a Monte Carlo simulation.
horizon=40
portfolio_stocks = do(10000)*{  # beginning of outer loop
current_wealth = 10000 # reset at the beginning of each simulated trajectory
for(t in 1:horizon) {  # start of inner loop
return_t = rnorm(1, mean = 0.06, sd = 0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}  # end of inner loop
# save the final value of wealth
current_wealth
}  # end of outer loop
# Upon inspecting portfolio_stocks, we find that it has a single column called result
ggplot(portfolio_stocks) +
geom_histogram(aes(x = result), bins=50)
library(tidyverse)
library(mosaic)
aapl_returns = read.csv("data/raw data/aapl_returns.csv", header = TRUE)
ggplot(aapl_returns) +
geom_histogram(aes(x = return, y = ..density..), binwidth = 0.005)
favstats(~return, data = aapl_returns) %>% round(4)
# count the really bad days where aapl lost at least 8% of its value in a single day
aapl_returns %>%
count(return <= -0.08)
aapl_returns %>%
count(return >= 0.10)
# function pnorm can give us how likely is such a four-sigma loss
# (lost at least 8% of its value in a single day) under the normal model
pnorm(-0.08, mean = 0.0013, sd = 0.0202)
# specifying that we want an upper-tail rather than a lower-tail probability
pnorm(0.10, mean = 0.0013, sd = 0.0202, lower.tail = FALSE)
annual_returns_since1928 = read.csv("data/raw data/annual_returns_since1928.csv", header = TRUE)
annual_returns_since1928 = annual_returns_since1928 %>%
# SP500_net, that measures each year’s “whole-market” return, net of inflation
mutate(SP500_net = SP500 - Inflation)
# compute the mean and standard deviation
favstats(~SP500_net, data = annual_returns_since1928) %>%
round(4)
ggplot(annual_returns_since1928) +
geom_histogram(aes(x = SP500_net, y = ..density..), binwidth = 0.05)
# run a Monte Carlo simulation.
horizon=40
portfolio_stocks = do(10000)*{  # beginning of outer loop
current_wealth = 10000 # reset at the beginning of each simulated trajectory
for(t in 1:horizon) {  # start of inner loop
return_t = rnorm(1, mean = 0.06, sd = 0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}  # end of inner loop
# save the final value of wealth
current_wealth
}  # end of outer loop
# Upon inspecting portfolio_stocks, we find that it has a single column called result
ggplot(portfolio_stocks) +
geom_histogram(aes(x = result), bins=50)
library(tidyverse)
library(mosaic)
aapl_returns = read.csv("data/raw data/aapl_returns.csv", header = TRUE)
ggplot(aapl_returns) +
geom_histogram(aes(x = return, y = ..density..), binwidth = 0.005)
favstats(~return, data = aapl_returns) %>% round(4)
# count the really bad days where aapl lost at least 8% of its value in a single day
aapl_returns %>%
count(return <= -0.08)
aapl_returns %>%
count(return >= 0.10)
# function pnorm can give us how likely is such a four-sigma loss
# (lost at least 8% of its value in a single day) under the normal model
pnorm(-0.08, mean = 0.0013, sd = 0.0202)
# specifying that we want an upper-tail rather than a lower-tail probability
pnorm(0.10, mean = 0.0013, sd = 0.0202, lower.tail = FALSE)
annual_returns_since1928 = read.csv("data/raw data/annual_returns_since1928.csv", header = TRUE)
annual_returns_since1928 = annual_returns_since1928 %>%
# SP500_net, that measures each year’s “whole-market” return, net of inflation
mutate(SP500_net = SP500 - Inflation)
# compute the mean and standard deviation
favstats(~SP500_net, data = annual_returns_since1928) %>%
round(4)
ggplot(annual_returns_since1928) +
geom_histogram(aes(x = SP500_net, y = ..density..), binwidth = 0.05)
# run a Monte Carlo simulation.
horizon=40
portfolio_stocks = do(10000)*{  # beginning of outer loop
current_wealth = 10000 # reset at the beginning of each simulated trajectory
for(t in 1:horizon) {  # start of inner loop
return_t = rnorm(1, mean = 0.06, sd = 0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}  # end of inner loop
# save the final value of wealth
current_wealth
}  # end of outer loop
# Upon inspecting portfolio_stocks, we find that it has a single column called result
ggplot(portfolio_stocks) +
geom_histogram(aes(x = result), bins=50)
favstats(~result, data = portfolio_stocks) %>% round(0)
library(tidyverse)
library(mosaic)
aapl_returns = read.csv("data/raw data/aapl_returns.csv", header = TRUE)
ggplot(aapl_returns) +
geom_histogram(aes(x = return, y = ..density..), binwidth = 0.005)
favstats(~return, data = aapl_returns) %>% round(4)
# count the really bad days where aapl lost at least 8% of its value in a single day
aapl_returns %>%
count(return <= -0.08)
aapl_returns %>%
count(return >= 0.10)
# function pnorm can give us how likely is such a four-sigma loss
# (lost at least 8% of its value in a single day) under the normal model
pnorm(-0.08, mean = 0.0013, sd = 0.0202)
# specifying that we want an upper-tail rather than a lower-tail probability
pnorm(0.10, mean = 0.0013, sd = 0.0202, lower.tail = FALSE)
annual_returns_since1928 = read.csv("data/raw data/annual_returns_since1928.csv", header = TRUE)
annual_returns_since1928 = annual_returns_since1928 %>%
# SP500_net, that measures each year’s “whole-market” return, net of inflation
mutate(SP500_net = SP500 - Inflation)
# compute the mean and standard deviation
favstats(~SP500_net, data = annual_returns_since1928) %>%
round(4)
ggplot(annual_returns_since1928) +
geom_histogram(aes(x = SP500_net, y = ..density..), binwidth = 0.05)
# run a Monte Carlo simulation.
horizon=40
portfolio_stocks = do(10000)*{  # beginning of outer loop
current_wealth = 10000 # reset at the beginning of each simulated trajectory
for(t in 1:horizon) {  # start of inner loop
return_t = rnorm(1, mean = 0.06, sd = 0.2)   # generate random return
current_wealth = current_wealth * (1 + return_t)   # update wealth via simple interest formula
}  # end of inner loop
# save the final value of wealth
current_wealth
}  # end of outer loop
# Upon inspecting portfolio_stocks, we find that it has a single column called result
ggplot(portfolio_stocks) +
geom_histogram(aes(x = result), bins=50)
favstats(~result, data = portfolio_stocks) %>% round(0)
portfolio_stocks %>% count(result < 10000)
4*40*24-2*40^2-4*24^2+64*40+32*24-514
32*54-512
-10*34^2+680*34+1216
32*54-514-4*54^2
-10*34^2+680*34-10450
-6*12*9+108*9-4*9^2
-4*2^2-3*3^2+50+24*3-3*2*3
180*45-2*45^2+160*20-4*400
560/72
2800+560*(70/9)-36*(70/9)^2
2800+560*(70/9)-36*(70/9)^2
16900/3
16900/3
2800+560*(70/9)-36*(70/9)^2
16900/3
175/4
knitr::opts_chunk$set(echo = TRUE)
x <- c(0, 2, 3, 5, 6)
y <- c(0, 0.1, 0.2, 1, 1)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
x <- c(0, 0, 2, 3, 5, 6)
y <- c(0, 0, 0.1, 0.2, 1, 1)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
x <- c(0, 2, 2, 3, 5, 6)
y <- c(0, 0, 0.1, 0.2, 1, 1)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
x <- c(0, 2, 2, 3, 3, 5, 6)
y <- c(0, 0, 0.1, 0.1, 0.2, 1, 1)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
x <- c(0, 2, 2, 3, 3, 5, 5, 6)
y <- c(0, 0, 0.1, 0.1, 0.2, 0.2, 1, 1)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
x <- c(0, 2, 2, 3, 3, 5, 5, 8)
y <- c(0, 0, 0.1, 0.1, 0.2, 0.2, 1, 1)
plot(x, y, lwd = 3,frame = FALSE, type = "l")
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
do*nflip(100, prob = 0.52)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
do(10)*nflip(100, prob = 0.52)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
# Remember the basic mantra of statistical inference: you’re certain if your results are repeatable.
# Let’s repeat our hypothetical survey 10 times
dessert_surveys <- do(10)*nflip(10000, prob = 0.52)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
# Remember the basic mantra of statistical inference: you’re certain if your results are repeatable.
# Let’s repeat our hypothetical survey 10 times
dessert_surveys <- do(10)*nflip(10000, prob = 0.52)
dessert_surveys = dessert_surveys %>%
mutate(huckleberry_prop = nflip/100)
ggplot(dessert_surveys) +
geom_histogram(aes(x = huckleberry_prop), binwidth = 0.01)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
# Remember the basic mantra of statistical inference: you’re certain if your results are repeatable.
# Let’s repeat our hypothetical survey 10 times
dessert_surveys <- do(10)*nflip(10000, prob = 0.52)
dessert_surveys = dessert_surveys %>%
mutate(huckleberry_prop = nflip / 100)
ggplot(dessert_surveys) +
geom_histogram(aes(x = huckleberry_prop), binwidth = 0.01)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
# Remember the basic mantra of statistical inference: you’re certain if your results are repeatable.
# Let’s repeat our hypothetical survey 10 times
dessert_surveys <- do(10000)*nflip(100, prob = 0.52)
dessert_surveys = dessert_surveys %>%
mutate(huckleberry_prop = nflip / 100)
ggplot(dessert_surveys) +
geom_histogram(aes(x = huckleberry_prop), binwidth = 0.01)
library(tidyverse)
library(mosaic)
# This function is designed to simulate coin flips
rflip(100, prob = 0.52)
# Remember the basic mantra of statistical inference: you’re certain if your results are repeatable.
# Let’s repeat our hypothetical survey 10 times
dessert_surveys <- do(10000)*nflip(100, prob = 0.52)
dessert_surveys = dessert_surveys %>%
# Let’s divide these numbers by 100 (the notional sample size of each survey),
# so we can interpret the results as a proportion
mutate(huckleberry_prop = nflip / 100)
ggplot(dessert_surveys) +
geom_histogram(aes(x = huckleberry_prop), binwidth = 0.01)
dessert_surveys %>%
summarize(std_err = sd(huckleberry_prop))
install.packages("extraDistr")
library(tidyverse)
library(extraDistr)
# Application: stocks and bonds
# Version 1: negative correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = -0.5  # correlation
# a single draw of stock/bond returns from the bivariate normal model
rbvnorm(n = 1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
library(tidyverse)
library(extraDistr)
# Application: stocks and bonds
# Version 1: negative correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = -0.5  # correlation
# a single draw of stock/bond returns from the bivariate normal model
rbvnorm(n = 1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
horizon = 40   # length of our investing horizon in years
weights = c(0.5, 0.5) # fraction of wealth in each asset?
total_wealth = 10000
wealth_by_asset = total_wealth * weights
for(t in 1:horizon) {
# Simulate a bivariate normal set of returns
returns = rbvnorm(1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# Recursively update wealth in each asset: simple interest formula
wealth_by_asset = wealth_by_asset * (1 + returns)
}
wealth_by_asset
library(tidyverse)
library(extraDistr)
# Application: stocks and bonds
# Version 1: negative correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = -0.5  # correlation
# a single draw of stock/bond returns from the bivariate normal model
rbvnorm(n = 1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# Set-up
horizon = 40   # length of our investing horizon in years
weights = c(0.5, 0.5) # fraction of wealth in each asset?
portfolio_sb_1 = do(10000)*{
total_wealth = 10000  # reset our initial wealth for each pass
wealth_by_asset = total_wealth * weights
for(t in 1:horizon) {
# 1) Simulate returns
returns = rbvnorm(1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# 2) Recursively update wealth
wealth_by_asset = wealth_by_asset * (1 + returns)
# 3) Rebalance
total_wealth = sum(wealth_by_asset)
wealth_by_asset = total_wealth * weights
}
c(rho = rho, result = total_wealth)  # save the final value of total wealth from each pass
}
library(tidyverse)
library(extraDistr)
# Application: stocks and bonds
# Version 1: negative correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = -0.5  # correlation
# a single draw of stock/bond returns from the bivariate normal model
rbvnorm(n = 1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# Set-up
horizon = 40   # length of our investing horizon in years
weights = c(0.5, 0.5) # fraction of wealth in each asset?
portfolio_sb_1 = do(10000)*{
total_wealth = 10000  # reset our initial wealth for each pass
wealth_by_asset = total_wealth * weights
for(t in 1:horizon) {
# 1) Simulate returns
returns = rbvnorm(1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# 2) Recursively update wealth
wealth_by_asset = wealth_by_asset * (1 + returns)
# 3) Rebalance
total_wealth = sum(wealth_by_asset)
wealth_by_asset = total_wealth * weights
}
c(rho = rho, result = total_wealth)  # save the final value of total wealth from each pass
}
ggplot(portfolio_sb_1) +
geom_histogram(aes(x=result), bins=50)
library(tidyverse)
library(extraDistr)
# Application: stocks and bonds
# Version 1: negative correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = -0.5  # correlation
# a single draw of stock/bond returns from the bivariate normal model
rbvnorm(n = 1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# Set-up
horizon = 40   # length of our investing horizon in years
weights = c(0.5, 0.5) # fraction of wealth in each asset?
portfolio_sb_1 = do(10000)*{
total_wealth = 10000  # reset our initial wealth for each pass
wealth_by_asset = total_wealth * weights
for(t in 1:horizon) {
# 1) Simulate returns
returns = rbvnorm(1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# 2) Recursively update wealth
wealth_by_asset = wealth_by_asset * (1 + returns)
# 3) Rebalance
total_wealth = sum(wealth_by_asset)
wealth_by_asset = total_wealth * weights
}
c(rho = rho, result = total_wealth)  # save the final value of total wealth from each pass
}
ggplot(portfolio_sb_1) +
geom_histogram(aes(x = result), bins = 50)
favstats(~result, data = portfolio_sb_1)
View(portfolio_sb_1)
knitr::opts_chunk$set(echo = TRUE)
utsat = read.csv("../data/raw data/utsat.csv", header = TRUE)
View(utsat)
library(tidyverse)
library(extraDistr)
# Application: stocks and bonds
# Version 1: negative correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = -0.5  # correlation
# a single draw of stock/bond returns from the bivariate normal model
rbvnorm(n = 1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# Set-up
horizon = 40   # length of our investing horizon in years
weights = c(0.5, 0.5) # fraction of wealth in each asset?
portfolio_sb_1 = do(10000)*{
total_wealth = 10000  # reset our initial wealth for each pass
wealth_by_asset = total_wealth * weights
for(t in 1:horizon) {
# 1) Simulate returns
returns = rbvnorm(1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# 2) Recursively update wealth
wealth_by_asset = wealth_by_asset * (1 + returns)
# 3) Rebalance
total_wealth = sum(wealth_by_asset)
wealth_by_asset = total_wealth * weights
}
c(rho = rho, result = total_wealth)  # save the final value of total wealth from each pass
}
ggplot(portfolio_sb_1) +
geom_histogram(aes(x = result), bins = 50)
# along with some summary statistics from favstats
favstats(~result, data = portfolio_sb_1)
# Version 2: positive correlation.
# parameters for bivariate normal
mu_stocks = 0.06
mu_bonds = 0.03
sigma_stocks = 0.2
sigma_bonds = 0.1
rho = 0.5  # now positive correlation
# Set-up
horizon = 40   # length of our investing horizon in years
weights = c(0.5, 0.5) # fraction of wealth in each asset?
portfolio_sb_2 = do(10000)*{
total_wealth = 10000  # reset our initial wealth for each pass
wealth_by_asset = total_wealth * weights
for(t in 1:horizon) {
# 1) Simulate returns
returns = rbvnorm(1, mu_stocks, mu_bonds, sigma_stocks, sigma_bonds, rho)
# 2) Recursively update wealth
wealth_by_asset = wealth_by_asset * (1 + returns)
# 3) Rebalance
total_wealth = sum(wealth_by_asset)
wealth_by_asset = total_wealth * weights
}
c(rho = rho, result = total_wealth)  # save the final value of total wealth from each pass
}
portfolios_all = bind_rows(portfolio_sb_1, portfolio_sb_2)
portfolios_all %>%
group_by(rho) %>%
summarize(fav_stats(result),
p_lose_money = sum(result < 10000) / n())
ggplot(portfolios_all) +
geom_histogram(aes(x=result)) +
facet_wrap(~rho, nrow=2) +
scale_x_log10()
